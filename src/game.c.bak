// game.c

#include "raylib.h"
#include "enemy.h"
#include "game.h"
#include "recursos.h"
#include <stdio.h>
#include <string.h>
#include <math.h>

#define MAX_ENEMIES 20

#define NUM_WAYPOINTS 84 // TOTAL DE PONTOS
#define ENEMY_DAMAGE_TO_CASTLE 20 // Dano de 20 por inimigo na torre

// â­ï¸ NOVAS CONSTANTES PARA O COMBATE INIMIGO VS HERÃ“I
#define ENEMY_ATTACK_RANGE 75.0f // Alcance de ataque dos inimigos (pixels)
#define ENEMY_DAMAGE_TO_HERO 5 Â  // Dano que o inimigo causa a um herÃ³i
#define ENEMY_ATTACK_INTERVAL 1.5f // Intervalo de ataque do inimigo (segundos)

Vector2 path[NUM_WAYPOINTS] = {
    { 50, 565 }, { 65, 560 }, { 80, 555 }, { 95, 550 }, { 110, 545 },
    { 125, 540 }, { 140, 535 }, { 155, 530 }, { 170, 525 }, { 185, 520 }, 
    { 200, 515 }, { 215, 510 }, { 230, 505 }, { 245, 500 }, { 270, 495 }, 
    { 300, 488 }, { 330, 480 }, { 360, 473 }, { 390, 465 }, { 420, 458 }, 
    { 430, 435 }, { 450, 435 }, { 470, 435 }, { 490, 435 }, { 490, 420 }, 
    { 490, 405 }, { 490, 390 }, { 480, 385 }, { 465, 380 }, { 450, 375 }, 
    { 435, 370 }, { 420, 365 }, { 405, 360 }, { 390, 360 }, { 375, 366 }, 
    { 360, 372 }, { 345, 378 }, { 330, 384 }, { 315, 390 }, { 300, 396 }, 
    { 285, 402 }, { 270, 408 }, { 250, 420 }, { 230, 435 }, 
    { 215, 427 }, { 200, 419 }, { 185, 411 }, { 170, 403 }, 
    { 155, 395 }, { 140, 387 },
    { 140, 372 },
    { 155, 364 }, { 170, 356 }, { 185, 348 }, { 200, 340 }, 
    { 215, 332 }, { 230, 324 }, { 245, 316 },
    { 260, 316 }, { 245, 308 }, { 230, 300 }, { 215, 292 }, { 200, 284 }, 
    { 185, 276 },
    { 205, 271 }, { 225, 266 }, { 245, 261 }, { 265, 256 }, 
    { 280, 249 }, { 295, 242 }, { 310, 235 },
    { 325, 228 }, { 340, 221 }, { 360, 231 }, { 380, 241 }, { 400, 251 }, 
    { 420, 261 }, { 440, 271 },
    { 460, 251 },
    { 497, 239 },
    { 534, 227 },
    { 571, 215 },
    { 608, 203 },
    { 645, 176 }
};
// â­ï¸ VARIÃVEIS DE ESTADO DO INIMIGO (SIMULANDO CAMPOS EM ENEMY STRUCT)
// Usamos arrays paralelos, pois nÃ£o temos acesso direto Ã  struct Enemy
static float enemyLastAttackTime[MAX_ENEMIES] = {0.0f}; // Tempo desde o Ãºltimo ataque
static int enemyTargetHero[MAX_ENEMIES] = {-1}; // Ãndice do herÃ³i alvo (-1 se nÃ£o estiver atacando)


static Enemy enemies[MAX_ENEMIES];
static int enemyCount = 0;
static Texture2D background;
static Texture2D towerTexture;
// âœ¨ ADIÃ‡ÃƒO 1: VariÃ¡vel para a textura da Fase 2
static Texture2D backgroundFase2;
static recursos gameRecursos;
static float spawnTimer = 0.0f;
static const float SPAWN_INTERVAL = 2.0f; // Spawn a new enemy every 2 seconds


// VariÃ¡veis GLOBAIS de Estado (Removidas as duplicaÃ§Ãµes)
GameState current_game_state = PLAYING; 
int enemies_defeated_count = 0; 
int towerHealth = CASTLE_MAX_HEALTH; // Usa a constante definida em game.h

// ğŸ’° VariÃ¡veis do sistema de menu
static bool menuAberto = false;
static Heroi herois[MAX_HEROIS];

// HerÃ³is colocados no mapa
static PlacedHero placedHeroes[MAX_HEROIS];
static int placedHeroCount = 0;
static bool placementMode = false;
static int selectedHeroType = -1; // Tipo do herÃ³i a ser colocado

// ğŸ’° Inicializa os herÃ³is disponÃ­veis
void InicializarHerois(void) {
Â  Â  // Heroi 1: Guerreiro
Â  Â  strcpy(herois[0].nome, "Guerreiro");
Â  Â  herois[0].custo = 50;
Â  Â  herois[0].dano = 10;
Â  Â  herois[0].alcance = 150;
    // âœ¨ Descomentar carregamento (Se nÃ£o estiver assim, ele nÃ£o funciona)
    herois[0].texture = LoadTexture("resources/perfil_guerreiro.png");
Â  Â  
Â  Â  // HerÃ³i 2: Bardo
Â  Â  strcpy(herois[1].nome, "Bardo");
Â  Â  herois[1].custo = 100;
Â  Â  herois[1].dano = 20;
Â  Â  herois[1].alcance = 300;
    // âœ¨ Descomentar carregamento
    herois[1].texture = LoadTexture("resources/perfil_bardo.png");
Â  Â  
Â  Â  // HerÃ³i 3: Paladino
Â  Â  strcpy(herois[2].nome, "Paladino");
Â  Â  herois[2].custo = 200;
Â  Â  herois[2].dano = 15;
Â  Â  herois[2].alcance = 200;
    // âœ¨ Descomentar carregamento
    herois[2].texture = LoadTexture("resources/perfil_paladino.png");
Â  Â  
Â  Â  // HerÃ³i 4: Mago
Â  Â  strcpy(herois[3].nome, "Mago");
Â  Â  herois[3].custo = 150;
Â  Â  herois[3].dano = 25;
Â  Â  herois[3].alcance = 250;
    // âœ¨ Descomentar carregamento
    herois[3].texture = LoadTexture("resources/perfil_mago.png");
}

// ğŸ’° FunÃ§Ã£o para comprar herÃ³i especÃ­fico
int ComprarHeroiEspecifico(recursos *r, int tipoHeroi) {
Â  Â  if (tipoHeroi >= 0 && tipoHeroi < MAX_HEROIS) {
Â  Â  Â  Â  if (r->moedas >= herois[tipoHeroi].custo) {
Â  Â  Â  Â  Â  Â  r->moedas -= herois[tipoHeroi].custo;
Â  Â  Â  Â  Â  Â  // Entrar no modo de colocaÃ§Ã£o
Â  Â  Â  Â  Â  Â  if (placedHeroCount < MAX_HEROIS) {
Â  Â  Â  Â  Â  Â  Â  Â  placementMode = true;
Â  Â  Â  Â  Â  Â  Â  Â  selectedHeroType = tipoHeroi;
Â  Â  Â  Â  Â  Â  Â  Â  menuAberto = false; // Fecha o menu
Â  Â  Â  Â  Â  Â  Â  Â  TraceLog(LOG_INFO, "%s comprado! Clique no mapa para colocar. Moedas restantes: %d", herois[tipoHeroi].nome, r->moedas);
Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  TraceLog(LOG_WARNING, "Limite de herÃ³is atingido! NÃ£o foi possÃ­vel comprar %s.", herois[tipoHeroi].nome);
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  return 1; // Compra realizada
Â  Â  Â  Â  }
Â  Â  }
Â  Â  return 0; // Moedas insuficientes ou tipo invÃ¡lido
}

// ğŸ’° FunÃ§Ã£o para desenhar o menu de herÃ³is
void DrawMenuHerois(void) {
Â  Â  int screenWidth = GetScreenWidth();
Â  Â  int screenHeight = GetScreenHeight();
Â  Â  
Â  Â  // Fundo semi-transparente para o menu (mais largo para 4 herÃ³is)
Â  Â  DrawRectangle(40, 90, screenWidth - 80, screenHeight - 180, (Color){0, 0, 0, 220});
Â  Â  
Â  Â  // Borda do menu
Â  Â  DrawRectangleLines(40, 90, screenWidth - 80, screenHeight - 180, GOLD);
Â  Â  
Â  Â  // TÃ­tulo do menu
Â  Â  DrawText("LOJA DE HERÃ“IS", screenWidth/2 - MeasureText("LOJA DE HERÃ“IS", 30)/2, 110, 30, GOLD);
Â  Â  DrawText("Pressione M para fechar", screenWidth/2 - MeasureText("Pressione M para fechar", 20)/2, 150, 20, LIGHTGRAY);
Â  Â  
Â  Â  // Desenha os cards dos herÃ³is - UM POUQUINHO MAIOR
Â  Â  int cardWidth = 185; Â // Aumentado de 170 para 185
Â  Â  int cardHeight = 245; // Aumentado de 230 para 245
Â  Â  int spacing = 20; Â  Â  // Reduzido um pouco o espaÃ§amento
Â  Â  int startX = (screenWidth - (MAX_HEROIS * cardWidth + (MAX_HEROIS - 1) * spacing)) / 2;
Â  Â  int startY = 190;
Â  Â  
Â  Â  for (int i = 0; i < MAX_HEROIS; i++) {
Â  Â  Â  Â  int cardX = startX + i * (cardWidth + spacing);
Â  Â  Â  Â  int cardY = startY;
Â  Â  Â  Â  
Â  Â  Â  Â  // Card background
Â  Â  Â  Â  Color cardColor = (Color){50, 50, 80, 255};
Â  Â  Â  Â  DrawRectangle(cardX, cardY, cardWidth, cardHeight, cardColor);
Â  Â  Â  Â  DrawRectangleLines(cardX, cardY, cardWidth, cardHeight, LIGHTGRAY);
Â  Â  Â  Â  
Â  Â  Â  Â  // Nome do herÃ³i
Â  Â  Â  Â  DrawText(herois[i].nome, cardX + cardWidth/2 - MeasureText(herois[i].nome, 20)/2, cardY + 20, 20, YELLOW);
Â  Â  Â  Â  
Â  Â  Â  Â  // Ãcone/textura do herÃ³i (um pouquinho maior)
Â  Â  Â  Â  int textureSize = 95; // Aumentado de 90 para 95
Â  Â  Â  Â  int textureX = cardX + (cardWidth - textureSize) / 2;
Â  Â  Â  Â  int textureY = cardY + 50;
Â  Â  Â  Â  DrawTexturePro(herois[i].texture,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  (Rectangle){0, 0, herois[i].texture.width, herois[i].texture.height},
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  (Rectangle){textureX, textureY, textureSize, textureSize},
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  (Vector2){0, 0}, 0.0f, WHITE);
Â  Â  Â  Â  
Â  Â  Â  Â  // EstatÃ­sticas (texto um pouquinho maior)
Â  Â  Â  Â  DrawText(TextFormat("Custo: %d$", herois[i].custo), cardX + 20, cardY + 160, 17, GOLD);
Â  Â  Â  Â  DrawText(TextFormat("Dano: %d", herois[i].dano), cardX + 20, cardY + 180, 17, RED);
Â  Â  Â  Â  DrawText(TextFormat("Alcance: %d", herois[i].alcance), cardX + 20, cardY + 200, 17, BLUE);
Â  Â  Â  Â  
Â  Â  Â  Â  // BotÃ£o de compra (um pouquinho maior)
Â  Â  Â  Â  Color btnColor = (gameRecursos.moedas >= herois[i].custo) ? GREEN : RED;
Â  Â  Â  Â  DrawRectangle(cardX + 20, cardY + cardHeight - 40, cardWidth - 40, 30, btnColor);
Â  Â  Â  Â  DrawText("COMPRAR", cardX + cardWidth/2 - MeasureText("COMPRAR", 17)/2, cardY + cardHeight - 35, 17, WHITE);
Â  Â  Â  Â  
Â  Â  Â  Â  // NÃºmero da tecla para comprar rÃ¡pido
Â  Â  Â  Â  DrawText(TextFormat("[%d]", i + 1), cardX + cardWidth - 25, cardY + cardHeight - 35, 17, YELLOW);
Â  Â  }
Â  Â  
Â  Â  // InstruÃ§Ãµes no rodapÃ©
Â  Â  DrawText("Use 1, 2, 3, 4 para comprar rapidamente ou clique nos botÃµes", 
Â  Â  Â  Â  Â  Â  Â  screenWidth/2 - MeasureText("Use 1, 2, 3, 4 para comprar rapidamente ou clique nos botÃµes", 17)/2, 
Â  Â  Â  Â  Â  Â  Â  startY + cardHeight + 25, 17, LIGHTGRAY);
}

// ğŸ’° FunÃ§Ã£o para verificar clique nos botÃµes do menu
void VerificarCliqueMenu(void) {
Â  Â  if (IsMouseButtonPressed(MOUSE_LEFT_BUTTON)) {
Â  Â  Â  Â  Vector2 mousePos = GetMousePosition();
Â  Â  Â  Â  int screenWidth = GetScreenWidth();
Â  Â  Â  Â  
Â  Â  Â  Â  int cardWidth = 185;
Â  Â  Â  Â  int cardHeight = 245;
Â  Â  Â  Â  int spacing = 20;
Â  Â  Â  Â  int startX = (screenWidth - (MAX_HEROIS * cardWidth + (MAX_HEROIS - 1) * spacing)) / 2;
Â  Â  Â  Â  int startY = 190;
Â  Â  Â  Â  
Â  Â  Â  Â  for (int i = 0; i < MAX_HEROIS; i++) {
Â  Â  Â  Â  Â  Â  int cardX = startX + i * (cardWidth + spacing);
Â  Â  Â  Â  Â  Â  int cardY = startY;
Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  // Verifica clique no botÃ£o de compra (coordenadas atualizadas)
Â  Â  Â  Â  Â  Â  Rectangle btnRect = {cardX + 20, cardY + cardHeight - 40, cardWidth - 40, 30};
Â  Â  Â  Â  Â  Â  if (CheckCollisionPointRec(mousePos, btnRect)) {
Â  Â  Â  Â  Â  Â  Â  Â  if (ComprarHeroiEspecifico(&gameRecursos, i)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  TraceLog(LOG_INFO, "%s comprado! Moedas restantes: %d", herois[i].nome, gameRecursos.moedas);
Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  TraceLog(LOG_WARNING, "Moedas insuficientes para comprar %s!", herois[i].nome);
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  break;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  }
}

// âœ¨ ADIÃ‡ÃƒO 2: FunÃ§Ã£o para iniciar a Fase 2 (transiÃ§Ã£o)
void IniciarFase2(void) {
    TraceLog(LOG_INFO, "Iniciando Fase 2...");
    
    // 1. Troca a textura de fundo. Agora 'background' aponta para a textura da Fase 2.
    background = backgroundFase2; 
    
    // 2. Resetar o estado do jogo para a prÃ³xima onda
    enemyCount = 0;
    enemies_defeated_count = 0; 
    towerHealth = CASTLE_MAX_HEALTH; // Restaura a vida da torre
    current_game_state = PLAYING; // Retorna ao estado de jogo

    // 3. Resetar variÃ¡veis de spawn e inimigos
    spawnTimer = 0.0f; 
    for(int i = 0; i < MAX_ENEMIES; i++) {
        enemyLastAttackTime[i] = 0.0f;
        enemyTargetHero[i] = -1;
    }
    
    // Aqui vocÃª tambÃ©m poderia redefinir o array 'path' se o caminho da Fase 2 fosse diferente.
    // Ex: path = novo_caminho_fase2;
}

// InicializaÃ§Ã£o
void InitGame(void) {
Â  Â  // Carrega as texturas
Â  Â  background = LoadTexture("resources/background_novo.jpg");
Â  Â  towerTexture = LoadTexture("resources/tower.png");
    // âœ¨ ADIÃ‡ÃƒO 3: Carregar a nova textura da Fase 2
    backgroundFase2 = LoadTexture("resources/background_fase_2.jpg");

Â  Â  inicializar_recursos(&gameRecursos);
Â  Â  InicializarHerois(); // ğŸ’° Inicializa o sistema de herÃ³is
Â  Â  
Â  Â  towerHealth = CASTLE_MAX_HEALTH; // NOVO: Usa a constante de vida mÃ¡xima
Â  Â  current_game_state = PLAYING; // NOVO: Inicia no estado PLAYING
Â  Â  enemies_defeated_count = 0; // NOVO: Zera o contador de vitÃ³ria
Â  Â  enemyCount = 0; // Zera a contagem para iniciar o spawn

Â  Â  // Limpa os tempos de ataque dos inimigos
Â  Â  for(int i = 0; i < MAX_ENEMIES; i++) {
Â  Â  Â  Â  enemyLastAttackTime[i] = 0.0f;
Â  Â  Â  Â  enemyTargetHero[i] = -1;
Â  Â  }
}

// AtualizaÃ§Ã£o
void UpdateGame(void) {
Â  Â  // ğŸ’° Alterna o menu com a tecla M
Â  Â  if (IsKeyPressed(KEY_M)) {
Â  Â  Â  Â  menuAberto = !menuAberto;
Â  Â  }

Â  Â  // NOVO: Se o jogo terminou ou estÃ¡ na tela de vitÃ³ria/derrota, bloqueia a maioria das aÃ§Ãµes
Â  Â  if (current_game_state != PLAYING) {
Â  Â  Â  Â  
        // âœ¨ ADIÃ‡ÃƒO 4: LÃ³gica de clique do botÃ£o "CONTINUAR" na tela de vitÃ³ria
        if (current_game_state == WAVE_WON && IsMouseButtonPressed(MOUSE_LEFT_BUTTON)) {
            int screenWidth = GetScreenWidth();
            // Coordenadas do botÃ£o (DEVE ser as mesmas usadas em DrawGame)
            Rectangle button_rect = { (screenWidth / 2) - 100, GetScreenHeight() / 2 + 50, 200, 50 };
            
            if (CheckCollisionPointRec(GetMousePosition(), button_rect)) {
                IniciarFase2(); // Chama a funÃ§Ã£o que inicia a Fase 2 e troca o fundo
                return; // Sai da atualizaÃ§Ã£o para evitar processar o frame no estado antigo
            }
        }
        
Â  Â  Â  Â  // Se menu estiver aberto, permite fechar (e processa compra se for rÃ¡pida)
Â  Â  Â  Â  if (menuAberto) {
Â  Â  Â  Â  Â  Â  VerificarCliqueMenu();
Â  Â  Â  Â  Â  Â  // ... (LÃ³gica de Compras rÃ¡pidas) ...
Â  Â  Â  Â  }
Â  Â  Â  Â  
Â  Â  Â  Â  return; // Sai se o jogo nÃ£o estÃ¡ em andamento
Â  Â  }
Â  Â  
Â  Â  // Se o menu estiver aberto, processa apenas inputs do menu
Â  Â  if (menuAberto) {
Â  Â  Â  Â  VerificarCliqueMenu();
Â  Â  Â  Â  // ... (LÃ³gica de Compras rÃ¡pidas) ...
Â  Â  Â  Â  return; // NÃ£o atualiza o jogo enquanto o menu estÃ¡ aberto
Â  Â  }

// ... (Resto da funÃ§Ã£o UpdateGame inalterado: colocaÃ§Ã£o de herÃ³is, ataque de herÃ³is, spawn de inimigos, movimento/ataque de inimigos) ...
    
Â  Â  // Se estiver no modo de colocaÃ§Ã£o, processa clique no mapa
Â  Â  if (placementMode) {
Â  Â  Â  Â  if (IsMouseButtonPressed(MOUSE_LEFT_BUTTON)) {
Â  Â  Â  Â  Â  Â  Vector2 mousePos = GetMousePosition();
Â  Â  Â  Â  Â  Â  // Coloca o herÃ³i na posiÃ§Ã£o clicada
Â  Â  Â  Â  Â  Â  placedHeroes[placedHeroCount].x = (int)mousePos.x;
Â  Â  Â  Â  Â  Â  placedHeroes[placedHeroCount].y = (int)mousePos.y;
Â  Â  Â  Â  Â  Â  placedHeroes[placedHeroCount].tipo = selectedHeroType;
Â  Â  Â  Â  Â  Â  placedHeroes[placedHeroCount].dano = herois[selectedHeroType].dano;
Â  Â  Â  Â  Â  Â  placedHeroes[placedHeroCount].alcance = herois[selectedHeroType].alcance;
Â  Â  Â  Â  Â  Â  placedHeroes[placedHeroCount].health = 100; // Vida inicial dos herÃ³is
Â  Â  Â  Â  Â  Â  placedHeroes[placedHeroCount].lastAttackTime = 0.0f;
Â  Â  Â  Â  Â  Â  placedHeroes[placedHeroCount].texture = herois[selectedHeroType].texture;
Â  Â  Â  Â  Â  Â  placedHeroCount++;
Â  Â  Â  Â  Â  Â  TraceLog(LOG_INFO, "%s colocado no mapa!", herois[selectedHeroType].nome);
Â  Â  Â  Â  Â  Â  // Sai do modo de colocaÃ§Ã£o
Â  Â  Â  Â  Â  Â  placementMode = false;
Â  Â  Â  Â  Â  Â  selectedHeroType = -1;
Â  Â  Â  Â  }
Â  Â  Â  Â  return; // NÃ£o atualiza o jogo enquanto no modo de colocaÃ§Ã£o
Â  Â  }
Â  Â  
Â  Â  
Â  Â  // 1. Atualizar herÃ³is colocados (LÃ³gica de Ataque do HerÃ³i)
Â  Â  for (int i = 0; i < placedHeroCount; i++) {
Â  Â  Â  Â  if (placedHeroes[i].health <= 0) continue; // HerÃ³i morto nÃ£o ataca

Â  Â  Â  Â  // Encontrar inimigo mais prÃ³ximo no alcance
Â  Â  Â  Â  int targetEnemy = -1;
Â  Â  Â  Â  float minDist = placedHeroes[i].alcance;
Â  Â  Â  Â  for (int j = 0; j < enemyCount; j++) {
Â  Â  Â  Â  Â  Â  if (enemies[j].active) {
Â  Â  Â  Â  Â  Â  Â  Â  float dx = placedHeroes[i].x - enemies[j].x;
Â  Â  Â  Â  Â  Â  Â  Â  float dy = placedHeroes[i].y - enemies[j].y;
Â  Â  Â  Â  Â  Â  Â  Â  float dist = sqrt(dx*dx + dy*dy);
Â  Â  Â  Â  Â  Â  Â  Â  if (dist < minDist) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  minDist = dist;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  targetEnemy = j;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }

Â  Â  Â  Â  // Atacar inimigo se encontrado
Â  Â  Â  Â  if (targetEnemy != -1) {
Â  Â  Â  Â  Â  Â  placedHeroes[i].lastAttackTime += GetFrameTime();
Â  Â  Â  Â  Â  Â  if (placedHeroes[i].lastAttackTime >= 1.0f) { // Ataque a cada 1 segundo
Â  Â  Â  Â  Â  Â  Â  Â  enemies[targetEnemy].health -= placedHeroes[i].dano;
Â  Â  Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  Â  Â  // NOVO: LÃ³gica de morte do inimigo pelo herÃ³i
Â  Â  Â  Â  Â  Â  Â  Â  if (enemies[targetEnemy].health <= 0) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // âœ¨ ADICIONA AS MOEDAS AO JOGADOR AQUI
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Requer: o campo `recompensa_moedas` na struct Enemy
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Requer: a funÃ§Ã£o `adicionar_moedas(&gameRecursos, valor)` em recursos.c/h
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  adicionar_moedas(&gameRecursos, enemies[targetEnemy].recompensa_moedas); 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  enemies[targetEnemy].active = 0;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  enemies_defeated_count++; // Incrementa o contador de vitÃ³ria
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  placedHeroes[i].lastAttackTime = 0.0f;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  }

Â  Â  // 2. Spawn new enemies if tower is alive and not at max enemies
Â  Â  if (towerHealth > 0 && enemyCount < MAX_ENEMIES) {
Â  Â  Â  Â  spawnTimer += GetFrameTime();
Â  Â  Â  Â  if (spawnTimer >= SPAWN_INTERVAL) {
Â  Â  Â  Â  Â  Â  enemies[enemyCount] = InitEnemy((int)path[0].x, (int)path[0].y);
Â  Â  Â  Â  Â  Â  // â­ï¸ Inicializa as variÃ¡veis de estado de ataque para o novo inimigo
Â  Â  Â  Â  Â  Â  enemyLastAttackTime[enemyCount] = 0.0f;
Â  Â  Â  Â  Â  Â  enemyTargetHero[enemyCount] = -1;
Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  enemyCount++;
Â  Â  Â  Â  Â  Â  spawnTimer = 0.0f;
Â  Â  Â  Â  }
Â  Â  }

Â  Â  // 3. Atualiza movimento e checa chegada Ã  torre (e adiciona ataque a herÃ³is)
Â  Â  for (int i = 0; i < enemyCount; i++) {
Â  Â  Â  Â  if (!enemies[i].active) continue;

Â  Â  Â  Â  // â­ï¸ LÃ“GICA DE ATAQUE DO INIMIGO AO HERÃ“I
Â  Â  Â  Â  int targetHeroIndex = enemyTargetHero[i];
Â  Â  Â  Â  
Â  Â  Â  Â  // Se o inimigo nÃ£o tem um alvo OU o alvo morreu/foi removido
Â  Â  Â  Â  if (targetHeroIndex == -1 || placedHeroes[targetHeroIndex].health <= 0) {
Â  Â  Â  Â  Â  Â  targetHeroIndex = -1; // Resetar o alvo

Â  Â  Â  Â  Â  Â  // Tenta encontrar um herÃ³i no alcance
Â  Â  Â  Â  Â  Â  float minDist = ENEMY_ATTACK_RANGE;
Â  Â  Â  Â  Â  Â  for (int j = 0; j < placedHeroCount; j++) {
Â  Â  Â  Â  Â  Â  Â  Â  if (placedHeroes[j].health > 0) { // SÃ³ mira em herÃ³is vivos
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  float dx = enemies[i].x - placedHeroes[j].x;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  float dy = enemies[i].y - placedHeroes[j].y;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  float dist = sqrt(dx*dx + dy*dy);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (dist <= minDist) { // Usa <= para mirar no herÃ³i que estÃ¡ no alcance
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  minDist = dist;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  targetHeroIndex = j;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  break; // Alvo encontrado! (Poderia ser o mais prÃ³ximo, mas o primeiro no alcance Ã© mais simples)
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  enemyTargetHero[i] = targetHeroIndex; // Define o novo alvo
Â  Â  Â  Â  }


Â  Â  Â  Â  if (targetHeroIndex != -1) {
Â  Â  Â  Â  Â  Â  // â­ï¸ O inimigo PARA e ataca o herÃ³i!
Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  enemyLastAttackTime[i] += GetFrameTime();
Â  Â  Â  Â  Â  Â  if (enemyLastAttackTime[i] >= ENEMY_ATTACK_INTERVAL) {
Â  Â  Â  Â  Â  Â  Â  Â  // Ataca o herÃ³i
Â  Â  Â  Â  Â  Â  Â  Â  placedHeroes[targetHeroIndex].health -= ENEMY_DAMAGE_TO_HERO;
Â  Â  Â  Â  Â  Â  Â  Â  TraceLog(LOG_INFO, "Inimigo %d atacou HerÃ³i %d. Vida Heroi: %d", i, targetHeroIndex, placedHeroes[targetHeroIndex].health);
Â  Â  Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  Â  Â  // Checa se o herÃ³i morreu
Â  Â  Â  Â  Â  Â  Â  Â  if (placedHeroes[targetHeroIndex].health <= 0) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  placedHeroes[targetHeroIndex].health = 0;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // O herÃ³i morto serÃ¡ "removido" na prÃ³xima iteraÃ§Ã£o do loop dos inimigos
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // ou por uma funÃ§Ã£o de limpeza (que nÃ£o estÃ¡ implementada).
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Por enquanto, apenas zeramos a vida para que ele seja ignorado.
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  enemyLastAttackTime[i] = 0.0f;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  // NÃ£o chama UpdateEnemy, pois o inimigo estÃ¡ atacando
Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  // Se nÃ£o hÃ¡ herÃ³i no alcance, o inimigo se move em direÃ§Ã£o Ã  torre
Â  Â  Â  Â  Â  Â  UpdateEnemy(&enemies[i]);
Â  Â  Â  Â  Â  Â  enemyTargetHero[i] = -1; // Garante que o alvo foi resetado
Â  Â  Â  Â  }
Â  Â  Â  Â  
Â  Â  Â  Â  // Checa se chegou na torre (LÃ³gica existente)
Â  Â  Â  Â  if (EnemyReachedTower(enemies[i]) && enemies[i].active) {
Â  Â  Â  Â  Â  Â  towerHealth -= ENEMY_DAMAGE_TO_CASTLE; 
Â  Â  Â  Â  Â  Â  enemies[i].active = 0; // Desativa o inimigo apÃ³s causar dano

Â  Â  Â  Â  Â  Â  if (towerHealth <= 0) {
Â  Â  Â  Â  Â  Â  Â  Â  towerHealth = 0;
Â  Â  Â  Â  Â  Â  Â  Â  current_game_state = GAME_OVER; // MUDANÃ‡A DE ESTADO: PERDEU
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  }

Â  Â  // 4. NOVO: LÃ³gica de VitÃ³ria
Â  Â  if (enemyCount >= MAX_ENEMIES && enemies_defeated_count >= MAX_ENEMIES) {
Â  Â  Â  Â  current_game_state = WAVE_WON; // MUDANÃ‡A DE ESTADO: VENCEU
Â  Â  }
}
// ğŸ”¹ FunÃ§Ã£o para desenhar UI normal
void DrawGameUI(void) {
Â  Â  // Fundo semi-transparente para as informaÃ§Ãµes
Â  Â  DrawRectangle(10, 10, 280, 90, (Color){0, 0, 0, 128});
Â  Â  
Â  Â  // Torre HP
Â  Â  DrawText(TextFormat("Torre HP: %d", towerHealth), 20, 20, 20, RED);
Â  Â  
Â  Â  // ğŸ’° Moedas
Â  Â  DrawText(TextFormat("Moedas: %d", get_moedas(&gameRecursos)), 20, 50, 20, GOLD);
Â  Â  
Â  Â  // InstruÃ§Ãµes para abrir menu
Â  Â  DrawText("M - Abrir loja de herois", 20, 80, 15, LIGHTGRAY);

Â  Â  // IndicaÃ§Ã£o de modo de colocaÃ§Ã£o
Â  Â  if (placementMode) {
Â  Â  Â  Â  DrawText("Clique no mapa para colocar o herÃ³i", GetScreenWidth()/2 - MeasureText("Clique no mapa para colocar o herÃ³i", 20)/2, 20, 20, YELLOW);
Â  Â  }
}

// Desenho
void DrawGame(void) {
Â  Â  BeginDrawing();
Â  Â  ClearBackground(BLACK);

Â  Â  // ğŸ”¹ Fundo
Â  Â  DrawTexturePro(
Â  Â  Â  Â  background,
Â  Â  Â  Â  (Rectangle){ 0, 0, background.width, background.height }, 
Â  Â  Â  Â  (Rectangle){ 0, 0, GetScreenWidth(), GetScreenHeight() }, 
Â  Â  Â  Â  (Vector2){ 0, 0 }, 
Â  Â  Â  Â  0.0f, 
Â  Â  Â  Â  WHITE 
Â  Â  );

// ... (Restante de DrawGame inalterado) ...
Â  Â  // ğŸ¯ DEBUG: Desenha o caminho dos inimigos
Â  Â  for (int i = 0; i < MAX_WAYPOINTS - 1; i++) {
Â  Â  Â  Â  DrawLineEx(path[i], path[i + 1], 3.0f, (Color){255, 255, 0, 128});
Â  Â  }
Â  Â  for (int i = 0; i < MAX_WAYPOINTS; i++) {
Â  Â  Â  Â  DrawCircle(path[i].x, path[i].y, 5.0f, BLUE);
Â  Â  Â  Â  DrawText(TextFormat("%d", i), path[i].x + 10, path[i].y - 10, 10, WHITE);
Â  Â  }

Â  Â  // ğŸ”¹ Torre
Â  Â  DrawTexture(towerTexture, 650, 100, WHITE);
Â  Â  
Â  Â  // ğŸ’° UI Normal
Â  Â  DrawGameUI();

Â  Â  // ğŸ”¹ Inimigos e HerÃ³is (SÃ³ desenha se o jogo estiver rodando)
Â  Â  if (current_game_state == PLAYING) {
Â  Â  Â  Â  for (int i = 0; i < enemyCount; i++) {
Â  Â  Â  Â  Â  Â  DrawEnemy(enemies[i]);
Â  Â  Â  Â  }

Â  Â  Â  Â  // Desenhar herÃ³is colocados
Â  Â  Â  Â  for (int i = 0; i < placedHeroCount; i++) {
Â  Â  Â  Â  Â  Â  if (placedHeroes[i].health <= 0) continue; // NÃ£o desenha herÃ³is mortos

Â  Â  Â  Â  Â  Â  Color heroColor;
Â  Â  Â  Â  Â  Â  switch (placedHeroes[i].tipo) {
Â  Â  Â  Â  Â  Â  Â  Â  case 0: heroColor = BLUE; break;
Â  Â  Â  Â  Â  Â  Â  Â  case 1: heroColor = GREEN; break;
Â  Â  Â  Â  Â  Â  Â  Â  case 2: heroColor = YELLOW; break;
Â  Â  Â  Â  Â  Â  Â  Â  case 3: heroColor = PURPLE; break;
Â  Â  Â  Â  Â  Â  Â  Â  default: heroColor = WHITE; break;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  DrawCircle(placedHeroes[i].x, placedHeroes[i].y, 20, heroColor);
Â  Â  Â  Â  Â  Â  // Desenhar alcance (cÃ­rculo semi-transparente)
Â  Â  Â  Â  Â  Â  DrawCircleLines(placedHeroes[i].x, placedHeroes[i].y, placedHeroes[i].alcance, (Color){heroColor.r, heroColor.g, heroColor.b, 100});
Â  Â  Â  Â  Â  Â  // â­ï¸ Desenhar alcance de ataque do inimigo (DEBUG)
Â  Â  Â  Â  Â  Â  // DrawCircleLines(enemies[i].x, enemies[i].y, ENEMY_ATTACK_RANGE, (Color){255, 0, 0, 100});
Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  // Desenhar barra de vida dos herÃ³is
Â  Â  Â  Â  Â  Â  int barWidth = 40;
Â  Â  Â  Â  Â  Â  int barHeight = 5;
Â  Â  Â  Â  Â  Â  int barX = placedHeroes[i].x - barWidth / 2;
Â  Â  Â  Â  Â  Â  int barY = placedHeroes[i].y - 30;
Â  Â  Â  Â  Â  Â  DrawRectangle(barX, barY, barWidth, barHeight, RED);
Â  Â  Â  Â  Â  Â  DrawRectangle(barX, barY, (int)(barWidth * (placedHeroes[i].health / 100.0f)), barHeight, GREEN);
Â  Â  Â  Â  }
Â  Â  }


Â  Â  // ğŸ’° Desenha o menu se estiver aberto
Â  Â  if (menuAberto) {
Â  Â  Â  Â  DrawMenuHerois();
Â  Â  }
Â  Â  
Â  Â  // =======================================================
Â  Â  // NOVO: TELA DE ESTADO FINAL (VITÃ“RIA OU DERROTA)
Â  Â  // =======================================================

Â  Â  if (current_game_state == GAME_OVER) {
Â  Â  Â  Â  // TELA DE DERROTA
Â  Â  Â  Â  DrawRectangle(0, 0, GetScreenWidth(), GetScreenHeight(), Fade(RED, 0.8f)); 
Â  Â  Â  Â  const char *message = "VOCÃŠ PERDEU! A TORRE FOI DESTRUÃDA.";
Â  Â  Â  Â  int message_len = MeasureText(message, 40);
Â  Â  Â  Â  DrawText(message, (GetScreenWidth() / 2) - (message_len / 2), GetScreenHeight() / 2 - 50, 40, WHITE);
Â  Â  Â  Â  
Â  Â  } else if (current_game_state == WAVE_WON) {
Â  Â  Â  Â  // TELA DE VITÃ“RIA
Â  Â  Â  Â  DrawRectangle(0, 0, GetScreenWidth(), GetScreenHeight(), Fade(DARKGREEN, 0.8f)); 
Â  Â  Â  Â  
Â  Â  Â  Â  const char *message = "VOCÃŠ GANHOU! IR PARA A FASE 2";
Â  Â  Â  Â  int message_len = MeasureText(message, 40);
Â  Â  Â  Â  DrawText(message, (GetScreenWidth() / 2) - (message_len / 2), GetScreenHeight() / 2 - 50, 40, GOLD);
Â  Â  Â  Â  
Â  Â  Â  Â  // Exemplo de botÃ£o
Â  Â  Â  Â  Rectangle button_rect = { (GetScreenWidth() / 2) - 100, GetScreenHeight() / 2 + 50, 200, 50 };
Â  Â  Â  Â  DrawRectangleRec(button_rect, YELLOW);
Â  Â  Â  Â  DrawText("CONTINUAR", button_rect.x + 50, button_rect.y + 15, 20, BLACK);
Â  Â  }

Â  Â  EndDrawing();
}

// FinalizaÃ§Ã£o
void CloseGame(void) {
Â  Â  // âœ¨ MODIFICAÃ‡ÃƒO 5: Libera a memÃ³ria de ambas as texturas de fundo
    UnloadTexture(background);
    UnloadTexture(backgroundFase2);
    
Â  Â  UnloadTexture(towerTexture);
Â  Â  
Â  Â  // ğŸ’° Descarrega texturas dos herÃ³is
Â  Â  for (int i = 0; i < MAX_HEROIS; i++) {
Â  Â  Â  Â  UnloadTexture(herois[i].texture);
Â  Â  }
}